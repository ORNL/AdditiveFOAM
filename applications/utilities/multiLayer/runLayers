#!/bin/bash
#------------------------------------------------------------------------------
# =========                 |
# \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox
#  \\    /   O peration     | Website:  https://openfoam.org
#   \\  /    A nd           | Copyright (C) 2011-2022 OpenFOAM Foundation
#    \\/     M anipulation  |
#------------------------------------------------------------------------------
# License
#     This file is part of OpenFOAM.
#
#     OpenFOAM is free software: you can redistribute it and/or modify it
#     under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     OpenFOAM is distributed in the hope that it will be useful, but WITHOUT
#     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
#     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
#     for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.
#
# Script
#     runLayers
#
# Description
#     Run an additiveFoam simulation for sequential layers.
#     Uses extrudeMesh to create layers and mapFields to initialize layers
#
#
# Usage:
#     PATH/TO/SCRIPT -nLayers # -layerThickness # -nCellsPerLayer #
#------------------------------------------------------------------------------

usage() {
    cat<<USAGE
Usage: ${0##*/} [OPTION] <application> ...
options:
  -nLayers          number of layers
  -layerThickness   thickness of each layer (deposition)
  -nCellsPerLayer   number of desired cells in each deposited layer
  -scanPathList     list of scan path files for each source and layer
  -help             print the usage
* Run an additiveFoam simulation for sequential layers.
* Currently, only a single repeating scan pattern is supported.
USAGE
}

function args_check {
	if [ $# -lt 3 ]; then
	    usage
	    exit 1
	fi
}

# Parse options
while [ "$#" -gt 0 ]
do
   case "$1" in
   -h | -help)
      usage && exit 0
      ;;
   -nLayers)
      nLayers="$2"
      shift 2
      ;;
   -layerThickness)
      layerThickness="$2"
      shift 2
      ;;
   -nCellsPerLayer)
      nCellsPerLayer="$2"
      shift 2
      ;;
   -scanPathList)
      scanPathList="$2"
      shift 2
      ;;
   --)
      shift
      break
      ;;
   -*)
      error "invalid option '$1'"
      ;;
   *)
      break
      ;;
   esac
done

args_check $nLayers $layerThickness $nCellsPerLayer $scanPathList

# Check number of heat sources
nSources=`foamDictionary -entry sources -value constant/heatSourceDict | wc -w`
nSources=$(($nSources - 2))

# Check that scan path list contains files for all sources and layers
nScanPathFiles=`grep -c "" $scanPathList`

# Discard first line of scanPathList which contains source names
nScanPathFiles=$((nScanPathFiles - 1))

if [ $nScanPathFiles != $nLayers ]; then
    echo "runLayers error: number of files in scan path list must match"
    echo "number of layers."
    exit 1
fi

# Check that there is a scan path list for each heat source    
nSourceLists=`head -n 1 $scanPathList | wc -w`

if [ $nSourceLists != $nSources ]; then
    echo "runLayers error: number of sources in scan path list must match"
    echo "number of sources in heatSourceDict."
    exit 1
fi

# create case directories
baseDir=${PWD}
caseList=()
for (( layer=0; layer<$nLayers; layer++ ))
do
    case="$baseDir/layer$layer"
    caseList+=($case)
    if [ -d $case ]; then rm -rf $case; fi
    mkdir $case

    cp -r "$baseDir/0" $case
    cp -r "$baseDir/constant" $case
    cp -r "$baseDir/system" $case
    
    # Iterate over list of heat sources
    for (( source=0; source<$nSources; source++ ))
    do
        # Get name of current heat source
        sourceName=`head -n 1 $scanPathList | cut -d " " -f $(($source + 1))`
        
        # Get name of scan path file associated with current heat source and layer
        layerPathName=`head -n $(($layer + 2)) $scanPathList | tail -n 1 | cut -d " " -f $(($source + 1))`
        
        # Set scan path for current heat source / layer
        foamDictionary -entry $sourceName/pathName -set $layerPathName  $case/constant/heatSourceDict
    done
done

# extrude mesh in each directory
for (( layer=0; layer<$nLayers; layer++ ))
do
    case=${caseList[$layer]}
    previous=${caseList[$((layer-1))]}

    if [ $layer -gt 0 ]
    then   
        nLayers0="$(foamDictionary -entry nLayers -value $previous/system/extrudeMeshDict)"
        thickness0="$(foamDictionary -entry linearDirectionCoeffs/thickness -value $previous/system/extrudeMeshDict)"
        thickness=`awk "BEGIN {print $thickness0 + $layerThickness; exit}"`

        foamDictionary -entry nLayers -set "$(($nLayers0+$nCellsPerLayer))" $case/system/extrudeMeshDict
        foamDictionary -entry linearDirectionCoeffs/thickness -set "$thickness" $case/system/extrudeMeshDict

        extrudeMesh -case $case > /dev/null 2>&1
    fi
done

# update simulation times and run layers sequentially
layerTime="$(cd ${caseList[0]} && foamDictionary -entry endTime -value system/controlDict)"

for (( layer=0; layer<$nLayers; layer++ ))
do
    case="${caseList[$layer]}"
    previous="${caseList[$((layer-1))]}"
    cd $case

    if [ $layer -gt 0 ]
    then
        previous=${caseList[$((layer-1))]}
        time="$(foamDictionary -entry endTime -value $previous/system/controlDict)"

        # update start and end time of simulation
        echo "Setting up layer $layer..."
        echo ""
        mv 0 "$time"
        endTime=`awk "BEGIN {print $time + $layerTime; exit}"`
        foamDictionary -entry startTime -set $time system/controlDict
        foamDictionary -entry endTime -set $endTime system/controlDict

        # Update wait time for scan path (assumes all layers/sources have equal times)
        for (( source=0; source<$nSources; source++ ))
        do
            # Get name of scan path file associated with current heat source and layer
            layerPathName=`head -n $(($layer + 2)) $scanPathList | tail -n 1 | cut -d " " -f $(($source + 1))`
            
            path=(`sed '2q;d' constant/$layerPathName`)
            path[5]=$time
            path=`echo $(echo ${path[@]}) | tr ' ' '\t\t'`
            sed -i "2s/.*/$path/" "$case/constant/$layerPathName"
        done

        # map previous layer fields to new layer
        mapFields -case $case -sourceTime "$time" -mapMethod mapNearest $previous > log.mapFields
    fi

    thickness="$(foamDictionary -entry linearDirectionCoeffs/thickness -value system/extrudeMeshDict)"
    
    # set powder height to the layer thickness 
    foamDictionary -entry regions -set \
    "(
        boxToCell
        {
            box (-1 -1 -$layerThickness) (1 1 1);
            fieldValues
            (
                volScalarFieldValue alpha.powder 1
            );
        }
    )" system/setFieldsDict
    
    nProcs="$(foamDictionary -entry numberOfSubdomains -value system/decomposeParDict)"

    transformPoints "translate=(0 0 -$thickness)" > log.transformPoints_0
    setFields > log.setFields
    decomposePar > log.decomposePar
    echo "Running additiveFoam for layer $layer..."
    echo ""
    mpirun -np $nProcs additiveFoam -parallel > log.additiveFoam
    reconstructPar -latestTime > log.reconstructPar
    transformPoints "translate=(0 0 $thickness)" > log.transformPoints_1
    echo "Completed layer $layer."
    echo ""
done

#------------------------------------------------------------------------------
